#!/usr/bin/env ruby

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '..', 'lib')

require 'typekit'
require 'optparse'
require 'json'

class Controller
  def initialize options
    @client = Typekit::Client.new options
  end

  def process command
    action, resource, parameters = parse command
    case action
    when 'show'
      print @client.get resource, parameters
    when 'create', 'update'
      print @client.post resource, parameters
    when 'delete'
      print @client.delete resource, parameters
    else
      raise 'The given action is unknown.'
    end
  rescue Exception => e
    puts e
  end

  def help
    puts <<-HELP
Usage: <action> <resource> [parameters]

    <action>        show, create, update, or delete
    <resource>      a list separated by white spaces
    [parameters]    a JSON-encoded hash (optional)

Examples:
    show kits
    show kits bas4cfe families vcsm
    show families vcsm i9
    show libraries trial { "page": 10, "per_page": 5 }
    create kits { "name": "Megakit", "domains": "localhost" }
    update kits bas4cfe { "name": "Ultrakit" }
    delete kits bas4cfe
HELP
  end

  protected

  def print output
    puts JSON.pretty_generate output
  end

  def parse command
    if command =~ /({.*})\s*$/
      begin
        parameters = JSON.parse $1
        raise unless parameters.is_a? Hash
        command = command.gsub /{.*}/, ''
      rescue
        raise 'Unable to parse the specified parameters.'
      end
    else
      parameters = {}
    end

    chunks = command.split(/\s+/).compact.reject &:empty?
    action, resource = chunks[0], chunks[1..-1]

    raise 'The action name is missing.' if action.nil?
    raise 'The action name is invalid.' unless action =~ /^\w+$/

    raise 'The resource name is missing.' if resource.empty?
    unless resource.all?{ |chunk| chunk =~ /^[\w\d]+$/ }
      raise 'The resource name is invalid.'
    end

    [ action, resource, parameters ]
  end
end

options = { version: 1, format: :json }

parser = OptionParser.new do |o|
  o.banner = 'Usage: typekit [options] [command]'

  o.separator ''
  o.separator 'Required options:'

  o.on('-t', '--token TOKEN', 'Set the API token') do |value|
    options[:token] = value
  end

  o.separator ''
  o.separator 'Other options:'

  o.on('-v', '--version VERSION', 'Set the API version') do |value|
    options[:version] = value
  end

  o.on('-f', '--format FORMAT', 'Set the data format') do |value|
    options[:format] = value
  end

  o.on_tail('-h', '--help', 'Show this message') do
    raise
  end
end

begin
  parser.parse!
rescue
  puts parser
  exit
end

begin
  controller = Controller.new options
rescue Exception => e
  puts e
  exit
end

unless ARGV.empty?
  controller.process ARGV.join(' ')
  exit
end

puts %{Type 'help' for help and 'exit' to exit.}

loop do
  begin
    print '> '
    command = $stdin.gets.strip
    next if command.empty?
    case command
    when 'exit'
      break
    when 'help'
      controller.help
    else
      controller.process command
    end
  rescue Interrupt
    break
  end
end

puts 'Bye.'

# vim: set ft=ruby
